---
title: "正規表現の先読み・後読み"
emoji: "👀"
type: "tech"
topics: ["正規表現"]
published: true
---

正規表現の「先読み（lookahead）」「後読み（lookbehind）」について紹介します。

# 正規表現の「位置へのマッチ」

正規表現は、文字列のパターンマッチに使われます。例えば `[0-9]{4}` は数字4つが並ぶ文字列にマッチする表現です。

多くの正規表現は「文字列」にマッチしますが、「文字列」ではなく「位置」にマッチする表現があります。これは、アンカーと呼ばれます。また、長さ0の文字列にマッチすると考えて、ゼロ幅アサーションとも呼ばれます。

アンカーの例として、`^`（先頭）`$`（末尾）`\b`（単語の境界）などがあります。

```regex
\bcat\b
```

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/anchor.png)

この例では、`cat` にはマッチします。一方、`category` や `concat` は `cat` を含みますが前後が単語の境界になっていないためマッチしません。

# 先読み

先読み（lookahead）は、位置にマッチする記法の一種です。位置の指定に正規表現を使います。`(?=` と `)` で囲む記法となっています。

```regex
a(?=..d)
```

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/lookahead.png)

これは、`a` の次に `任意の2文字＋d` が来る場合に限り、`a` にマッチする、という正規表現です。`abracadabra` という文字列の中には `a` がいくつかあります。このうち、先読みの「`任意の2文字＋d` が来る」という条件に当てはまるのはひとつだけです。

# 後読み

後読み（lookbehind）は先読みと似ています。

* `(?=regex)` : 先読み。次に `regex` がくる位置にマッチ。
* `(?<=regex)` : 後読み。前に `regex` がくる位置にマッチ。

```regex
(?<=<em>)cat(?=</em>)
```

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/lookbehind.png)

これは、後読みと先読みを両方使って、`cat` が `<em>` と `</em>` で囲まれている場合にのみマッチします。

:::message
余談ですが、個人的にはどちらが「先」でどちらが「後」か、少し混乱します。「先読み」は一般的な言葉として使われますが、「後読み」が聞き慣れない言葉でピンときません。しかも、「先読み」の「先」は「このあとに続く部分」という意味なので、「後」が対義語になっていない感じです。「後読み」の代わりにどのように名付けるのが適切かは難しいところですが、例えば「返り読み」などと名付けたほうが良かったのではないでしょうか。
:::

:::message
（2022-08-23追記）
[コメント](https://zenn.dev/link/comments/e572eff21f78cb)で、lookbehindに「戻り読み」という訳語を採用している事例を教えていただきました。ありがとうございます。
:::

# 否定先読み・否定後読み

先読みと後読みのバリエーションとして以下のものがあります。

* `(?!regex)` : 否定先読み。次に `regex` がこない位置にマッチ。
* `(?<!regex)` : 否定後読み。前に `regex` がこない位置にマッチ。

```regex
(?!2022)\d{4}
```

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/lookahead_neg.png)

`\d{4}` は数字4つの並びにマッチしますが、否定先読み `(?!2022)` は `2022` の前の位置にはマッチしません。そのため、全体として `(?!2022)\d{4}` は `2022` にはマッチしません。

# 先読みが便利な場合(1)

先読みが有益な場合はどのような場合でしょうか。実のところ、先読みを使わないと書けないパターンというものはありません。

しかし、先読みを使うと楽に書けるパターンがあります。そのうちのひとつが、以下のパターンです。

```regex
(?=.*hoge.*)(?=.*fuga.*)(?=.*piyo.*).*
```

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/lookahead_and.png)

これは、`.*` という正規表現の前に3つの先読みがあります。この3つの先読みは、ある特定の位置以降の文字列が `.*hoge.*` / `.*fuga.*` / `.*piyo.*` の3つの正規表現すべてにマッチすることを要求しています。そのため、全体として `hoge` / `fuga` / `piyo` の3つを含む文字列にマッチする正規表現となります。

別の言い方をすると、先読みを使うと複数の正規表現のAND演算が書ける、ということになります。

なお、`hoge` / `fuga` / `piyo` の3つを含む文字列にマッチする正規表現として、以下のものはどうでしょうか。

```regex
.*hoge.*fuga.*piyo.*
```

これは、3つの文字列がこの順番どおりに出てきたときのみマッチします。どの順番で出てきても良いようにするには、以下のようになります（見やすくするため途中で改行を入れています）。

```regex
.*hoge.*fuga.*piyo.*|.*hoge.*piyo.*fuga.*|
.*fuga.*piyo.*hoge.*|.*fuga.*hoge.*piyo.*|
.*piyo.*hoge.*fuga.*|.*piyo.*fuga.*hoge.*
```

長い正規表現は読みづらく感じることが多いです。同じ意味の正規表現が、先読みを知っていれば `(?=.*hoge.*)(?=.*fuga.*)(?=.*piyo.*).*` と短く書けます。

:::message
（2022-08-23追記）
[コメント](https://zenn.dev/link/comments/e572eff21f78cb)で、最短一致 `.*?` を使うほうが効率的な正規表現パターンになることを指摘いただきました。ありがとうございます。
:::

# 先読みが便利な場合(2)

もうひとつ、先読みが便利なパターンを挙げます。

数字が何個か並んでいる文字列に対して、3桁ごとにカンマを挿入するコードを、正規表現で書いてみます。ここではプログラミング言語にPerlを使います。

```perl
#!/usr/bin/perl

$text = '12345678';
$text =~ s/(?<=\d)(?=(\d\d\d)+$)/,/g;
print $text;
```

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/lookahead_replace.png)

実行すると、確かに `12345678` が `12,345,678` に置換されています。しかし、なぜこのコードでうまくいくのでしょうか。詳しく見てみましょう。

![](https://github.com/usami-k/technote/raw/main/2022/regex_lookahead/public/lookahead_replace_note.png)

`(?<=\d)(?=(\d\d\d)+$)` は位置にマッチする正規表現です。`(?<=\d)` なので直前が数字であり、`(?=(\d\d\d)+$)` なので直後から数字3つの繰り返し（つまり、数字6つなど数字が3の倍数個）で文字列が終わる、という位置です。`12345678` に対しては、`2` と `3` の間、`5` と `6` の間、の2箇所にマッチします。

位置にマッチする正規表現は、「長さ0の文字列」にマッチする正規表現です。マッチした箇所を `,` という文字列に置換するという処理は、該当の位置に `,` を挿入する処理と同じです。したがって、`2` と `3` の間、`5` と `6` の間に `,` が挿入されます。

先読みを知っていると、このようにスマートなコードが書けます。

:::message
プログラミング言語でPerlを使いましたが、もちろん他の言語でも問題ありません。正規表現の歴史の中で、正規表現の普及と発展にPerl言語が大きく貢献したと言われています。そのため、正規表現といえばPerlというイメージがあり、今回はPerlを採用しました。
:::

# 注意点

先読みや後読みは、正規表現の歴史の中では比較的新しい機能です。そのため、言語や環境によってはサポートされていない場合があります。ご注意ください。

# 参考文献

<!-- textlint-disable -->

* 新屋良磨，鈴木勇介，高田謙　著、[正規表現技術入門――最新エンジン実装と理論的背景](https://gihyo.jp/dp/ebook/2015/978-4-7741-7326-9)、技術評論社、2015。
* Jeffrey E.F. Friedl　著、株式会社ロングテール／長尾 高弘　訳、[詳説 正規表現 第3版](https://www.oreilly.co.jp/books/9784873113593/)、オライリー・ジャパン、2008。
* Jan Goyvaerts, Steven Levithan　著、長尾 高弘　訳、[正規表現クックブック](https://www.oreilly.co.jp/books/9784873114507/)、オライリー・ジャパン、2010。

<!-- textlint-enable -->

# 便利ツール

* [Expressions](https://www.apptorium.com/expressions) : 正規表現を簡単に試せるmacOSアプリ。本記事の正規表現のスクリーンショットはこのアプリのもの。
* [CodeRunner](https://coderunnerapp.com/) : 各種プログラミング言語を簡単に動かせるmacOSアプリ。本記事のPerlコードのスクリーンショットはこのアプリのもの。

# 補足

この記事は、[KyotoLT Online 第27回](https://kyotolt.connpass.com/event/252441/)で発表した内容（[正規表現の少し進んだ機能](https://speakerdeck.com/usamik26/regex-lookahead)）を記事の形に書き直したものです。
